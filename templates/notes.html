<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAJORA - Notes</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='notes.css') }}">
</head>
<body class="notes-page-active">
    <div class="container">
        <header>
            <div class="header-top">
                <div class="logo-container">
                    <img src="{{ url_for('static', filename='favicon.png') }}" alt="Yajora Logo" class="logo">
                    <div id="appDropdown" class="dropdown-content">
                        <a href="/~">Yajora Tasks</a>
                        <a href="/notes">Yajora Notes</a>
                    </div>
                </div>
                <h1 id="headerTitle">Notes</h1>
                <div class="profile-container">
                    <button id="profileBtn" class="profile-btn">
                        {% if profile_image %}
                            <img src="{{ profile_image }}" alt="Profile" class="profile-img">
                        {% else %}
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                                <circle cx="12" cy="10" r="3" stroke="currentColor" stroke-width="2"/>
                                <path d="M6 20c0-3.5 3-6 6-6s6 2.5 6 6" stroke="currentColor" stroke-width="2"/>
                            </svg>
                        {% endif %}
                    </button>
                </div>
            </div>
        </header>

        <div class="search-section">
            <div class="search-container">
                <div id="searchTagsContainer" class="search-tags-container"></div>
                <input type="text" id="searchInput" placeholder="Search notes..." class="search-input">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="11" cy="11" r="8" stroke="currentColor" stroke-width="2"/>
                    <path d="m21 21-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </div>
        </div>

        <div id="notesContainer" class="notes-grid">
            <!-- Notes will be dynamically inserted here -->
        </div>

    </div>

    <!-- Notification Toast -->
    <div id="notificationToast" class="notification-toast">
        <span id="notificationText"></span>
    </div>

    <!-- Floating Action Button -->
    <div class="add-task-btn" id="addNoteBtn">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </div>

    <!-- Note Inspector Modal -->
    <div class="modal" id="noteModal">
        <div class="modal-content" id="noteModalContent">
            <!-- This content will be dynamically generated by JS -->
        </div>
    </div>

    <!-- New Note Creation Modal -->
    <div class="modal" id="createNoteModal">
        <div class="modal-content-create">
            <h2>New Note</h2>
            <form id="createNoteForm">
                <div class="form-group">
                    <label for="newNoteTitle">Title (optional)</label>
                    <input type="text" id="newNoteTitle" placeholder="Enter a title for your note">
                </div>
                <div class="form-group">
                    <label for="newNoteContent">Content (Markdown supported)</label>
                    <textarea id="newNoteContent" rows="10" placeholder="What's on your mind?"></textarea>
                </div>
                <div class="form-actions">
                    <button type="button" id="cancelCreateBtn" class="btn btn-secondary">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Profile Modal -->
    <div class="modal" id="profileModal">
        <div class="modal-content profile-modal-content">
            <div class="profile-header">
                <h3>Profile Settings</h3>
                <div class="current-profile-display">
                    {% if profile_image %}
                        <img src="{{ profile_image }}" alt="Current Profile" class="current-profile-img">
                    {% else %}
                        <div class="current-profile-placeholder">
                            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                                <circle cx="12" cy="10" r="3" stroke="currentColor" stroke-width="2"/>
                                <path d="M6 20c0-3.5 3-6 6-6s6 2.5 6 6" stroke="currentColor" stroke-width="2"/>
                            </svg>
                        </div>
                    {% endif %}
                    <div class="profile-info">
                        <div class="current-username">{{ username }}</div>
                        <div class="current-email">{{ email or 'No email set' }}</div>
                    </div>
                </div>
            </div>
            <form id="profileForm" class="profile-form">
                <div class="form-section">
                    <h4>Profile Picture</h4>
                    <div class="form-group">
                        <label for="profileImageInput">Upload new image:</label>
                        <input type="file" id="profileImageInput" accept="image/*">
                        <small>Supported formats: JPG, PNG, GIF. Max size: 5MB</small>
                    </div>
                </div>

                <div class="form-section">
                    <h4>Account Information</h4>
                    <div class="form-group">
                        <label for="usernameInput">Username:</label>
                        <input type="text" id="usernameInput" value="{{ username }}" placeholder="Enter username">
                    </div>
                    <div class="form-group">
                        <label for="emailInput">Email:</label>
                        <input type="email" id="emailInput" value="{{ email or '' }}" placeholder="Enter email address">
                    </div>
                </div>

                <div class="form-section">
                    <h4>Security</h4>
                    <div class="form-group">
                        <label for="passwordInput">New Password:</label>
                        <input type="password" id="passwordInput" placeholder="Enter new password (leave empty to keep current)">
                        <small>Leave empty if you don't want to change your password</small>
                    </div>
                </div>

                <div class="form-section">
                    <h4>Data & Account</h4>
                    <div class="welcome-message" id="welcomeMessage"></div>
                    <div class="data-actions">
                        <button id="importBtn">Import Data</button>
                        <button id="exportBtn">Export Data</button>
                        <button id="logoutBtn" class="btn-danger">Logout</button>
                    </div>
                </div>

                <div class="modal-actions">
                    <button type="button" id="cancelProfileBtn" class="btn-secondary">Cancel</button>
                    <button type="submit" class="btn-primary">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <div id="player-modal" class="player-modal">
        <button id="close-player-btn" class="close-player-btn" title="Back to Browse">
            <svg viewBox="0 0 24 24">
                <path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"></path>
            </svg>
        </button>
        <div id="player-container"></div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const notesContainer = document.getElementById('notesContainer');
            const addNoteBtn = document.getElementById('addNoteBtn');
            const noteModal = document.getElementById('noteModal');
            const createNoteModal = document.getElementById('createNoteModal');
            const createNoteForm = document.getElementById('createNoteForm');
            const cancelCreateBtn = document.getElementById('cancelCreateBtn');
            const appDropdown = document.getElementById('appDropdown');
            const logo = document.querySelector('.logo');
            const searchInput = document.getElementById('searchInput');

            // State
            let notes = [];
            let editingNoteId = null;
            let currentTags = [];
            let searchTerms = []; // Changed from searchTerm to searchTerms array
            let currentInputValue = ''; // Current value being typed in input field
            let currentEditor = null;

            // Player constants
            const apiKey = 'f2d7ae9dee829174c475e32fe8f993dc';
            const posterBaseUrl = 'https://image.tmdb.org/t/p/w500';
            const backdropBaseUrl = 'https://image.tmdb.org/t/p/original';
            const playerBaseUrl = 'https://player.videasy.net';

            // Notification functions
            function showNotification(message, duration = 2000) {
                const toast = document.getElementById('notificationToast');
                const text = document.getElementById('notificationText');
                text.textContent = message;
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, duration);
            }

            // Local storage functions
            function saveNotesToCache(notes) {
                try {
                    localStorage.setItem('cached_notes', JSON.stringify(notes));
                    localStorage.setItem('cache_timestamp', Date.now().toString());
                } catch (e) {
                    console.log('Failed to save notes to cache:', e);
                }
            }

            function loadNotesFromCache() {
                try {
                    const cached = localStorage.getItem('cached_notes');
                    const timestamp = localStorage.getItem('cache_timestamp');
                    if (cached && timestamp) {
                        // Check if cache is less than 24 hours old
                        const age = Date.now() - parseInt(timestamp);
                        if (age < 24 * 60 * 60 * 1000) { // 24 hours
                            return JSON.parse(cached);
                        } else {
                            // Clear old cache
                            localStorage.removeItem('cached_notes');
                            localStorage.removeItem('cache_timestamp');
                        }
                    }
                } catch (e) {
                    console.log('Failed to load notes from cache:', e);
                }
                return null;
            }

            // Player functions
            async function fetchData(url) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return await response.json();
                } catch (error) { console.error('Error fetching data:', error); return null; }
            }

            function openPlayerModal(url, mediaType, itemId) {
                const playerModal = document.getElementById('player-modal');
                const playerContainer = document.getElementById('player-container');
                if (playerContainer && playerModal) {
                    playerContainer.innerHTML = `<iframe src="${url}" allow="autoplay; fullscreen" allowfullscreen></iframe>`;
                    playerModal.classList.add('active');
                    document.body.classList.add('modal-open');

                    window.addEventListener('message', async (event) => {
                        if (event.source !== playerContainer.querySelector('iframe').contentWindow) return;

                        if (event.data.type === 'episodeEnded') {
                            const nextEpisodeButton = document.createElement('button');
                            nextEpisodeButton.id = 'next-episode-btn';
                            nextEpisodeButton.textContent = 'Next Episode';
                            nextEpisodeButton.onclick = async () => {
                                const [_, __, currentSeason, currentEpisode] = url.split('/');
                                const nextEpisodeNumber = parseInt(currentEpisode) + 1;
                                const seasonsUrl = `https://api.themoviedb.org/3/tv/${itemId}?api_key=${apiKey}`;
                                const seasonsData = await fetchData(seasonsUrl);
                                const currentSeasonData = seasonsData.seasons.find(s => s.season_number == currentSeason);
                                if (currentSeasonData && nextEpisodeNumber <= currentSeasonData.episode_count) {
                                    const nextEpisodeUrl = `${playerBaseUrl}/tv/${itemId}/${currentSeason}/${nextEpisodeNumber}`;
                                    openPlayerModal(nextEpisodeUrl, mediaType, itemId);
                                } else {
                                    // Handle end of season or series
                                    closePlayerModal();
                                }
                            };
                            playerContainer.appendChild(nextEpisodeButton);
                        }
                    });
                }
            }

            function closePlayerModal() {
                const playerModal = document.getElementById('player-modal');
                const playerContainer = document.getElementById('player-container');
                if (playerContainer && playerModal) {
                    playerModal.classList.remove('active');
                    playerContainer.innerHTML = '';
                    document.body.classList.remove('modal-open');
                }
            }

            // Socket.IO setup
            const socket = io();
            socket.on('tldr_generated', (data) => {
                // Update the note in our local state
                const noteIndex = notes.findIndex(n => n.id === data.note_id);
                if (noteIndex !== -1) {
                    notes[noteIndex].tldr = data.tldr;
                    saveNotesToCache(notes); // Update cache
                }

                // If we're currently viewing this note in the modal, update it
                if (editingNoteId === data.note_id) {
                    const tldrElement = document.querySelector('.tldr-content');
                    const loadingElement = document.querySelector('.tldr-loading');
                    if (tldrElement) {
                        tldrElement.textContent = data.tldr;
                        tldrElement.classList.remove('generating');
                    }
                    if (loadingElement) {
                        loadingElement.remove();
                    }
                }
            });

            socket.on('tldr_error', (data) => {
                // Update the note in our local state
                const noteIndex = notes.findIndex(n => n.id === data.note_id);
                if (noteIndex !== -1) {
                    notes[noteIndex].tldr = data.error;
                }

                // If we're currently viewing this note in the modal, update it
                if (editingNoteId === data.note_id) {
                    const tldrElement = document.querySelector('.tldr-content');
                    const loadingElement = document.querySelector('.tldr-loading');
                    if (tldrElement) {
                        tldrElement.textContent = data.error;
                        tldrElement.classList.remove('generating');
                    }
                    if (loadingElement) {
                        loadingElement.remove();
                    }
                }
            });

            socket.on('title_generated', (data) => {
                // Update the note in our local state
                const noteIndex = notes.findIndex(n => n.id === data.note_id);
                if (noteIndex !== -1) {
                    notes[noteIndex].title = data.title;
                    saveNotesToCache(notes); // Update cache
                }

                // Update the card title if visible
                const card = document.querySelector(`.note-card[data-note-id="${data.note_id}"]`);
                if (card) {
                    const titleElement = card.querySelector('.note-card-title');
                    if (titleElement) {
                        titleElement.textContent = data.title;
                    }
                }

                // If we're currently viewing this note in the modal, update the title
                if (editingNoteId === data.note_id) {
                    const titleElement = document.querySelector('.sidebar-header .title');
                    if (titleElement) {
                        titleElement.textContent = data.title;
                    }
                }
            });

            socket.on('title_error', (data) => {
                // Update the note in our local state
                const noteIndex = notes.findIndex(n => n.id === data.note_id);
                if (noteIndex !== -1) {
                    notes[noteIndex].title = data.error;
                }

                // Update the card title if visible
                const card = document.querySelector(`.note-card[data-note-id="${data.note_id}"]`);
                if (card) {
                    const titleElement = card.querySelector('.note-card-title');
                    if (titleElement) {
                        titleElement.textContent = data.error;
                    }
                }

                // If we're currently viewing this note in the modal, update the title
                if (editingNoteId === data.note_id) {
                    const titleElement = document.querySelector('.sidebar-header .title');
                    if (titleElement) {
                        titleElement.textContent = data.error;
                    }
                }
            });

            // --- API Communication ---
            const api = {
                getNotes: async () => (await fetch('/api/notes')).json(),
                createNote: async (title, content) => (await fetch('/api/notes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ title, content }) })).json(),
                updateNote: async (id, title, content, tags) => (await fetch(`/api/notes/${id}`, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ title, content, tags }) })).json(),
                deleteNote: async (id) => (await fetch(`/api/notes/${id}`, { method: 'DELETE' })).json(),
                generateTldr: async (id) => (await fetch(`/api/notes/${id}/generate-tldr`, { method: 'POST' })).json(),
            };

            // --- Search and Filtering ---
            function highlightSearchTerm(text) {
                // Combine search terms and current input value
                const allSearchTerms = [...searchTerms];
                if (currentInputValue.trim()) {
                    allSearchTerms.push(currentInputValue.trim());
                }

                if (!allSearchTerms || allSearchTerms.length === 0) return text;

                // Extract search words (excluding type keywords)
                let searchWords = [];
                for (const term of allSearchTerms) {
                    const trimmedTerm = term.trim();
                    if (trimmedTerm && !typeKeywords[trimmedTerm]) {
                        searchWords.push(trimmedTerm);
                    }
                }

                // If no search words, return original text
                if (searchWords.length === 0) return text;

                // Create regex for highlighting search words
                const searchPattern = searchWords.join('|');
                const regex = new RegExp(`(${searchPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                return text.replace(regex, '<mark>$1</mark>');
            }

            // Type keyword mappings for filtering
            const typeKeywords = {
                'movie': 'Movie',
                'movies': 'Movie',
                'tv': 'TV Show',
                'tv show': 'TV Show',
                'show': 'TV Show',
                'shows': 'TV Show',
                'video': 'YouTube',
                'videos': 'YouTube',
                'youtube': 'YouTube',
                'reddit': 'Reddit',
                'x': 'X',
                'twitter': 'X',
                'wikipedia': 'Wikipedia',
                'wiki': 'Wikipedia'
            };

            // --- Search Tag Management ---
            function renderSearchTags() {
                const container = document.getElementById('searchTagsContainer');
                container.innerHTML = '';
                searchTerms.forEach((term, index) => {
                    const tag = document.createElement('span');
                    tag.className = 'search-tag';
                    tag.innerHTML = `${term}<span class="search-tag-remove" data-index="${index}">Ã—</span>`;
                    container.appendChild(tag);
                });
            }

            function addSearchTag(term) {
                const trimmedTerm = term.trim().toLowerCase();
                if (trimmedTerm && !searchTerms.includes(trimmedTerm)) {
                    searchTerms.push(trimmedTerm);
                    renderSearchTags();
                    renderNotes();
                }
            }

            function removeSearchTag(index) {
                searchTerms.splice(index, 1);
                renderSearchTags();
                renderNotes();
            }

            function clearAllSearchTags() {
                searchTerms = [];
                renderSearchTags();
                renderNotes();
            }

            function getFilteredNotes() {
                // Combine search terms and current input value
                const allSearchTerms = [...searchTerms];
                if (currentInputValue.trim()) {
                    allSearchTerms.push(currentInputValue.trim());
                }

                if (allSearchTerms.length === 0) {
                    return notes;
                }

                // Start with all notes
                let filteredNotes = notes;

                // Apply each search term as a filter
                for (const term of allSearchTerms) {
                    const trimmedTerm = term.trim();
                    if (!trimmedTerm) continue;

                    // Check if this term is a type keyword
                    if (typeKeywords[trimmedTerm]) {
                        // Filter by type
                        filteredNotes = filteredNotes.filter(note => note.note_type === typeKeywords[trimmedTerm]);
                    } else {
                        // Search within current filtered notes for this term
                        filteredNotes = filteredNotes.filter(note => {
                            // Search in title
                            if (note.title && note.title.toLowerCase().includes(trimmedTerm)) {
                                return true;
                            }
                            // Search in content
                            if (note.content && note.content.toLowerCase().includes(trimmedTerm)) {
                                return true;
                            }
                            // Search in tags
                            if (note.tags && Array.isArray(note.tags)) {
                                if (note.tags.some(tag => tag.toLowerCase().includes(trimmedTerm))) {
                                    return true;
                                }
                            }
                            // Search in note type (for broader matching)
                            if (note.note_type && note.note_type.toLowerCase().includes(trimmedTerm)) {
                                return true;
                            }
                            // Search in TLDR
                            if (note.tldr && note.tldr.toLowerCase().includes(trimmedTerm)) {
                                return true;
                            }
                            return false;
                        });
                    }
                }

                return filteredNotes;
            }

            // --- Main Note Grid Rendering ---
            function renderNotes() {
                const filteredNotes = getFilteredNotes();
                notesContainer.innerHTML = '';
                if (filteredNotes.length === 0) {
                    if (searchTerms.length > 0) {
                        const searchText = searchTerms.join(', ');
                        notesContainer.innerHTML = `<p style="text-align:center; color:#888; grid-column: 1 / -1;">No notes found matching "${searchText}".</p>`;
                    } else {
                        notesContainer.innerHTML = '<p style="text-align:center; color:#888; grid-column: 1 / -1;">You have no notes yet. Click the + button to create one!</p>';
                    }
                    return;
                }
                filteredNotes.forEach(note => {
                    const card = document.createElement('div');
                    card.className = 'note-card';
                    card.dataset.noteId = note.id;

                    let cardContent = '';
                    switch (note.note_type) {
                        case 'Movie':
                        case 'TV Show':
                            card.classList.add('movie-card');
                            const details = note.metadata?.details;
                            const posterPath = details?.poster_path;
                            const posterUrl = posterPath ? `https://image.tmdb.org/t/p/w500${posterPath}` : 'https://via.placeholder.com/500x750.png?text=No+Image';
                            const title = details?.title || details?.name || note.title;
                            const releaseDate = details?.release_date || details?.first_air_date;
                            const year = releaseDate ? new Date(releaseDate).getFullYear() : 'N/A';
                            cardContent = `
                                <img src="${posterUrl}" alt="Poster for ${title}" class="note-card-poster" loading="lazy">
                                <div class="note-card-overlay">
                                    <h3 class="note-card-title">${highlightSearchTerm(title)}</h3>
                                    <p class="note-card-meta">${year}</p>
                                    <div class="play-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                                    </div>
                                </div>`;
                            break;
                        case 'Wikipedia':
                            card.classList.add('wikipedia-card');
                            cardContent = `
                                <img src="https://upload.wikimedia.org/wikipedia/commons/8/80/Wikipedia-logo-v2.svg" alt="Wikipedia Logo" class="wikipedia-logo">
                                <h3 class="note-card-title">${highlightSearchTerm(note.metadata?.details?.title || note.title)}</h3>`;
                            break;
                        case 'YouTube':
                             card.classList.add('youtube-card');
                             const videoId = note.metadata?.video_id;
                             const thumbnailUrl = videoId ? `https://img.youtube.com/vi/${videoId}/hqdefault.jpg` : 'https://via.placeholder.com/500x281.png?text=No+Thumbnail';
                             const videoTitle = note.metadata?.details?.title || 'YouTube Video';
                             cardContent = `
                                <img src="${thumbnailUrl}" alt="YouTube Thumbnail" class="youtube-thumbnail" loading="lazy">
                                <div class="youtube-overlay">
                                </div>
                                <div class="play-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                                </div>
                                <div class="youtube-title-overlay">
                                    <h3 class="note-card-title">${highlightSearchTerm(videoTitle)}</h3>
                                </div>`;
                            break;
                        case 'Reddit':
                            card.classList.add('reddit-card-grid');
                            const redditDetails = note.metadata?.details;
                            const subreddit = note.metadata?.subreddit;
                            if (redditDetails) {
                                cardContent = `
                                    <div class="reddit-card-grid-top">
                                        <img src="/static/Reddit_Logo.webp" alt="Reddit Snoo" class="snoo-logo-grid">
                                    </div>
                                    <div class="reddit-card-grid-bottom">
                                        <h3 class="note-card-title">${highlightSearchTerm(redditDetails.title)}</h3>
                                        <p class="reddit-subreddit-grid">r/${subreddit}</p>
                                    </div>
                                `;
                            } else {
                                cardContent = `
                                    <h3 class="note-card-title">${highlightSearchTerm(note.title)}</h3>
                                    <div class="note-card-content">Could not load Reddit post.</div>
                                `;
                            }
                            break;
                        case 'X':
                            card.classList.add('x-card-grid');
                            const xDetails = note.metadata?.details;
                            if (xDetails) {
                                cardContent = `
                                    <div class="x-card-grid-top">
                                        <img src="/static/x-logo.png" alt="X Logo" class="x-logo-grid">
                                    </div>
                                    <div class="x-card-grid-bottom">
                                        <h3 class="note-card-title">${highlightSearchTerm(`Tweet by @${xDetails.author_name}`)}</h3>
                                    </div>
                                `;
                            } else {
                                cardContent = `
                                    <h3 class="note-card-title">${highlightSearchTerm(note.title)}</h3>
                                    <div class="note-card-content">Could not load X post.</div>
                                `;
                            }
                            break;
                        default: // Standard Note
                            cardContent = `
                                <h3 class="note-card-title">${highlightSearchTerm(note.title || '')}</h3>
                                <div class="note-card-content">${marked.parse(highlightSearchTerm(note.content || ''))}</div>`;
                            break;
                    }
                    card.innerHTML = cardContent;
                    notesContainer.appendChild(card);
                });
            }

            // --- Helper function to calculate relative time ---
            function timeAgo(dateString) {
                const now = new Date();
                const past = new Date(dateString);
                const diffMs = now - past;
                const diffSeconds = Math.floor(diffMs / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);
                const diffWeeks = Math.floor(diffDays / 7);
                const diffMonths = Math.floor(diffDays / 30);
                const diffYears = Math.floor(diffDays / 365);

                if (diffSeconds < 60) return 'just now';
                if (diffMinutes < 60) return diffMinutes === 1 ? '1 minute ago' : `${diffMinutes} minutes ago`;
                if (diffHours < 24) return diffHours === 1 ? '1 hour ago' : `${diffHours} hours ago`;
                if (diffDays < 7) return diffDays === 1 ? '1 day ago' : `${diffDays} days ago`;
                if (diffWeeks < 4) return diffWeeks === 1 ? '1 week ago' : `${diffWeeks} weeks ago`;
                if (diffMonths < 12) return diffMonths === 1 ? '1 month ago' : `${diffMonths} months ago`;
                return diffYears === 1 ? '1 year ago' : `${diffYears} years ago`;
            }

            // --- NEW: Inspector Modal Builder ---
            let saveTimeout;
            function debouncedSave() {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    if (editingNoteId) handleSaveNote();
                }, 500);
            }

            function openNoteModal(note) {
                editingNoteId = note ? note.id : null;
                currentTags = note ? (note.tags || []) : [];
                let isStandard = false;
                document.body.classList.add('modal-open');
                const modalContent = document.getElementById('noteModalContent');
                modalContent.innerHTML = ''; // Clear previous content

                // Create main layout
                const mainContent = document.createElement('div');
                mainContent.className = 'modal-main-content';

                const sidebar = document.createElement('div');
                sidebar.className = 'modal-sidebar';

                // --- Populate Main Content (Left Panel) ---
                let mainContentHTML = '';
                let url = note.metadata?.url || (note.metadata?.details?.id ? `https://www.themoviedb.org/${note.note_type === 'Movie' ? 'movie' : 'tv'}/${note.metadata.details.id}` : null);
                let useDefaultSidebar = true; // Flag to control sidebar generation

                switch (note.note_type) {
                    case 'Movie':
                    case 'TV Show':
                        const posterPath = note.metadata?.details?.poster_path;
                        const posterUrl = posterPath ? `https://image.tmdb.org/t/p/w780${posterPath}` : 'https://via.placeholder.com/500x750.png?text=No+Image';
                        mainContentHTML = `
                            <div class="media-preview-container">
                                <img src="${posterUrl}" loading="lazy" class="media-poster-preview" alt="Poster">
                                ${url ? `<a href="${url}" target="_blank" class="view-details-btn">View Details</a>` : ''}
                            </div>
                        `;
                        break;
                    case 'Wikipedia':
                        url = note.metadata?.url;
                        if (url) {
                            mainContent.classList.add('wikipedia-embed-content');
                            mainContentHTML = `
                                <div class="media-preview-container">
                                    <iframe src="${url}" frameborder="0"></iframe>
                                </div>
                            `;
                        } else {
                            mainContentHTML = `<div class="content-preview">No Wikipedia URL found for this note.</div>`;
                        }
                        break;
                    case 'YouTube':
                        const videoId = note.metadata?.video_id;
                        url = videoId ? `https://www.youtube.com/watch?v=${videoId}` : null;
                        if (videoId) {
                            mainContent.classList.add('youtube-video-content');
                            mainContentHTML = `
                                <div class="media-preview-container">
                                    <iframe src="https://www.youtube.com/embed/${videoId}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                </div>
                            `;
                        } else {
                            mainContentHTML = `<div class="content-preview">No video ID found for this note.</div>`;
                        }
                        break;
                    case 'Reddit':
                        const redditDetails = note.metadata?.details;
                        url = redditDetails?.url;
                        if (redditDetails) {
                            mainContent.classList.add('reddit-card-content');
                            const subreddit = note.metadata?.subreddit;
                            mainContentHTML = `
                                <div class="reddit-card-custom">
                                    <div class="reddit-card-top">
                                        <img src="/static/Reddit_Logo.webp" alt="Reddit Snoo" class="snoo-logo">
                                    </div>
                                    <div class="reddit-card-bottom">
                                        <div class="reddit-logo-text">reddit</div>
                                        <h3 class="reddit-post-title">${redditDetails.title}</h3>
                                        <p class="reddit-subreddit">r/${subreddit}</p>
                                        <a href="${url}" target="_blank" class="reddit-view-btn">VIEW ON REDDIT</a>
                                    </div>
                                </div>
                            `;
                        } else {
                            mainContentHTML = `<div class="content-preview">Could not load Reddit post.</div>`;
                        }
                        break;
                    case 'X':
                        const xDetails = note.metadata?.details;
                        url = xDetails?.url;
                        if (xDetails) {
                            mainContent.classList.add('x-card-content');
                            mainContentHTML = `
                                <div class="x-card-custom">
                                    <div class="x-card-top">
                                        <img src="/static/x-logo.png" alt="X Logo" class="x-logo">
                                    </div>
                                    <div class="x-card-middle">
                                        <div class="x-logo-text">x</div>
                                        <h3 class="x-post-title">Tweet by @${xDetails.author_name}</h3>
                                    </div>
                                    <div class="x-card-bottom">
                                        <a href="${url}" target="_blank" class="x-view-btn">VIEW ON X</a>
                                    </div>
                                </div>
                            `;
                        } else {
                            mainContentHTML = `<div class="content-preview">Could not load X post.</div>`;
                        }
                        break;
                    default:
                        isStandard = true;
                        mainContentHTML = `<div id="wysiwyg-editor"></div>`;
                        break;
                }
                mainContent.innerHTML = mainContentHTML;

                // --- Populate Sidebar (Right Panel) ---
                if (useDefaultSidebar) {
                    const title = note.metadata?.details?.title || note.metadata?.details?.name || note.title;
                    const tldr = note.tldr || note.metadata?.details?.overview || note.metadata?.details?.summary || 'No summary available.';
                    const isGenerating = note.tldr === 'Generating summary...';

                    // Determine source text based on URL
                    let sourceText = note.note_type;
                    if (url) {
                        if (url.includes('letterboxd.com')) sourceText = 'Letterboxd';
                        else if (url.includes('serializd.com')) sourceText = 'Serializd';
                        else if (url.includes('themoviedb.org')) sourceText = 'TMDB';
                    }

                    sidebar.innerHTML = `
                        <div class="sidebar-header">
                            <h2 class="title">${title}</h2>
                            <p class="meta">
                                <span class="date">${timeAgo(note.created_at)}</span>
                                ${url ? `<a href="${url}" target="_blank" class="source-link"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><polyline points="15,3 21,3 21,9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><line x1="10" y1="14" x2="21" y2="3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg> ${sourceText}</a>` : `<span class="source">${sourceText}</span>`}
                            </p>
                        </div>

                        <div class="sidebar-section">
                            <h3 class="section-title">TLDR</h3>
                            <p class="tldr-content ${isGenerating ? 'generating' : ''}">${isGenerating ? '' : tldr}</p>
                            ${isGenerating ? '<div class="tldr-loading"><div class="loading-spinner"></div> Generating AI summary...</div>' : ''}
                            ${!isGenerating && (tldr === 'No summary available.' || !tldr) ? `<button class="generate-tldr-btn" data-note-id="${note.id}">Generate AI Summary</button>` : ''}
                        </div>

                        <div class="sidebar-section">
                            <h3 class="section-title">TAGS</h3>
                            <div class="tags-container">
                                <!-- Tags will be rendered here -->
                            </div>
                        </div>

                        ${isStandard ? '' : `
                        <div class="sidebar-section">
                            <h3 class="section-title">
                                MIND NOTES <span class="question-mark" title="Your personal notes. Saved automatically.">?</span>
                            </h3>
                            <textarea id="mindNotesInput" placeholder="Type here to add a note...">${note.content || ''}</textarea>
                        </div>
                        `}

                        <div class="sidebar-footer">
                            <button class="action-btn" id="deleteNoteBtn" title="Delete Note">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                            </button>
                        </div>
                    `;
                }

                modalContent.appendChild(mainContent);
                modalContent.appendChild(sidebar);
                renderTags();

                if (isStandard) {
                    const editorElement = document.getElementById('wysiwyg-editor');
                    currentEditor = new Quill(editorElement, {
                        theme: 'snow',
                        placeholder: 'Start writing your note...',
                        modules: {
                            toolbar: [
                                [{ 'header': [1, 2, 3, false] }],
                                ['bold', 'italic', 'underline', 'strike'],
                                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                                ['blockquote', 'code-block'],
                                ['link'],
                                ['clean']
                            ]
                        }
                    });
                    // Set initial content by converting markdown to HTML
                    const initialHtml = marked.parse(note.content || '');
                    currentEditor.root.innerHTML = initialHtml;
                    currentEditor.on('text-change', () => {
                        debouncedSave();
                    });
                }

                // Add auto-save for mind notes
                if (!isStandard) {
                    const mindNotesInput = document.getElementById('mindNotesInput');
                    if (mindNotesInput) {
                        mindNotesInput.addEventListener('input', debouncedSave);
                        mindNotesInput.addEventListener('blur', () => {
                            clearTimeout(saveTimeout);
                            handleSaveNote();
                        });
                    }
                }

                // Event delegation for generate TLDR button (since it's dynamically created)
                modalContent.addEventListener('click', async (e) => {
                    if (e.target.classList.contains('generate-tldr-btn')) {
                        const button = e.target;
                        const noteId = button.dataset.noteId;

                        // Disable button immediately to prevent multiple clicks
                        button.disabled = true;
                        button.textContent = 'Generating...';
                        button.style.opacity = '0.6';

                        try {
                            // Call API to generate TLDR
                            await api.generateTldr(noteId);

                            // Update UI to show loading state
                            const tldrContent = modalContent.querySelector('.tldr-content');
                            const loadingDiv = document.createElement('div');
                            loadingDiv.className = 'tldr-loading';
                            loadingDiv.innerHTML = '<div class="loading-spinner"></div> Generating AI summary...';

                            tldrContent.classList.add('generating');
                            tldrContent.textContent = '';
                            button.replaceWith(loadingDiv);

                        } catch (error) {
                            console.error('Generate TLDR failed:', error);
                            // Re-enable button on error
                            button.disabled = false;
                            button.textContent = 'Generate AI Summary';
                            button.style.opacity = '1';
                        }
                    }
                });

                // Add event listener for adding tags
                const tagsContainer = document.querySelector('.tags-container');
                tagsContainer.addEventListener('click', (e) => {
                    if (e.target.closest('.add-tag-btn')) {
                        // Toggle the visibility of the input controls
                        const controls = document.querySelector('.add-tag-controls');
                        if (controls) {
                            controls.remove();
                        } else {
                            const tagsRow = document.querySelector('.tags-row');
                            if (tagsRow) {
                                const newControls = document.createElement('div');
                                newControls.className = 'add-tag-controls';
                                newControls.innerHTML = `
                                    <input type="text" class="add-tag-input" placeholder="Add a tag...">
                                    <button class="add-tag-plus-btn"><svg viewBox="0 0 24 24" fill="currentColor"><line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2"/><line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2"/></svg></button>
                                `;
                                tagsRow.parentElement.insertBefore(newControls, tagsRow);
                                const input = newControls.querySelector('.add-tag-input');
                                input.focus();
                            }
                        }
                    } else if (e.target.closest('.add-tag-plus-btn')) {
                        // Add the tag
                        const input = document.querySelector('.add-tag-input');
                        const tag = input.value.trim();
                        if (tag && !currentTags.includes(tag)) {
                            currentTags.push(tag);
                            renderTags();
                            handleSaveNote(); // Auto-save after adding tag
                        }
                    } else if (e.target.classList.contains('delete-tag')) {
                        // Delete the tag
                        const tagSpan = e.target.parentElement;
                        const tagText = tagSpan.textContent.slice(0, -1); // remove Ã—
                        const index = currentTags.indexOf(tagText);
                        if (index > -1) {
                            currentTags.splice(index, 1);
                            renderTags();
                            handleSaveNote(); // Auto-save after deleting tag
                        }
                    }
                });

                // Handle Enter key in input
                tagsContainer.addEventListener('keypress', (e) => {
                    if (e.target.classList.contains('add-tag-input') && e.key === 'Enter') {
                        const input = e.target;
                        const tag = input.value.trim();
                        if (tag && !currentTags.includes(tag)) {
                            currentTags.push(tag);
                            renderTags();
                            handleSaveNote(); // Auto-save after adding tag
                        }
                    }
                });

                noteModal.style.display = 'flex';
            }
            
            function closeNoteModal() {
                // Stop any playing YouTube videos before closing
                const modalContent = document.getElementById('noteModalContent');
                const iframe = modalContent.querySelector('iframe');
                if (iframe && iframe.src && iframe.src.includes('youtube.com')) {
                    // Replace src with about:blank to stop the video completely
                    iframe.src = 'about:blank';
                }

                noteModal.style.display = 'none';
                document.body.classList.remove('modal-open');
                editingNoteId = null;
                currentTags = [];
                if (currentEditor) {
                    currentEditor = null;
                }
            }

            // --- Function to render tags ---
            function renderTags() {
                const tagsContainer = document.querySelector('.tags-container');
                if (!tagsContainer) return;

                const note = notes.find(n => n.id === editingNoteId);
                if (!note) return;

                const typeTagMap = {
                    'Movie': 'Movie',
                    'TV Show': 'TV Show',
                    'Wikipedia': 'Wikipedia Article',
                    'YouTube': 'YouTube Video',
                    'Reddit': 'Reddit Post',
                    'X': 'X Post',
                    'Standard': null
                };
                const typeTag = typeTagMap[note.note_type];
                const allTags = typeTag ? [typeTag, ...currentTags] : currentTags;
                const existingControls = document.querySelector('.add-tag-controls');
                const isControlsVisible = existingControls && !existingControls.classList.contains('hidden');
                tagsContainer.innerHTML = `
                    ${isControlsVisible ? `<div class="add-tag-controls">
                        <input type="text" class="add-tag-input" placeholder="Add a tag...">
                        <button class="add-tag-plus-btn"><svg viewBox="0 0 24 24" fill="currentColor"><line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2"/><line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2"/></svg></button>
                    </div>` : ''}
                    <div class="tags-row">
                        <button class="add-tag-btn">+ Add tag</button>
                        ${allTags.map((tag, index) => {
                            const isTypeTag = typeTag && index === 0;
                            return `<span class="tag${isTypeTag ? '' : ' user-tag'}">${tag}${isTypeTag ? '' : '<span class="delete-tag">Ã—</span>'}</span>`;
                        }).join('')}
                    </div>
                `;
            }

            // --- Event Handlers ---
            async function handleSaveNote() {
                if (!editingNoteId) return;

                const noteToUpdate = notes.find(n => n.id === editingNoteId);
                const title = noteToUpdate.title; // Title is not editable in this view
                let content;
                if (currentEditor) {
                    const html = currentEditor.root.innerHTML;
                    const turndownService = new TurndownService();
                    content = turndownService.turndown(html);
                } else {
                    content = document.getElementById('mindNotesInput') ? document.getElementById('mindNotesInput').value : noteToUpdate.content;
                }

                try {
                    const result = await api.updateNote(editingNoteId, title, content, currentTags);
                    const index = notes.findIndex(n => n.id === editingNoteId);
                    if (index !== -1) notes[index] = result.note;
                    saveNotesToCache(notes); // Update cache
                    renderNotes(); // Refresh grid in case content changed
                    // Removed alert for auto-save
                } catch (error) {
                    console.error('Save failed:', error);
                    // Could show a subtle notification instead
                }
            }

            async function handleDeleteNote() {
                if (!editingNoteId) return;
                try {
                    await api.deleteNote(editingNoteId);
                    notes = notes.filter(n => n.id !== editingNoteId);
                    saveNotesToCache(notes); // Update cache
                    renderNotes();
                    closeNoteModal();
                } catch (error) {
                    console.error('Delete failed:', error);
                }
            }

            // --- Event Listeners ---
            addNoteBtn.addEventListener('click', openCreateModal);

            // Event delegation for modal actions
            noteModal.addEventListener('click', (e) => {
                if (e.target.closest('#cancelNoteBtn')) closeNoteModal();
                if (e.target.closest('#deleteNoteBtn')) handleDeleteNote();
                if (e.target === noteModal) closeNoteModal();
            });

            // Auto-save on blur for mind notes
            noteModal.addEventListener('blur', (e) => {
                if (e.target.id === 'mindNotesInput') {
                    handleSaveNote();
                }
            }, true);

            notesContainer.addEventListener('click', (e) => {
                if (e.target.closest('.play-icon')) {
                    const card = e.target.closest('.note-card');
                    const noteId = card.dataset.noteId;
                    const note = notes.find(n => n.id === noteId);
                    if (note && (note.note_type === 'Movie' || note.note_type === 'TV Show')) {
                        const mediaType = note.note_type === 'Movie' ? 'movie' : 'tv';
                        const itemId = note.metadata.details.id;
                        const playerUrl = `${playerBaseUrl}/${mediaType}/${itemId}`;
                        // Create full-screen player overlay
                        const playerOverlay = document.createElement('div');
                        playerOverlay.id = 'full-player-overlay';
                        playerOverlay.innerHTML = `
                            <button id="close-full-player" style="position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.5); border: none; color: white; padding: 10px; cursor: pointer; z-index: 10001;">
                                <svg viewBox="0 0 24 24"><path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z"></path></svg>
                            </button>
                            <iframe src="${playerUrl}" allow="autoplay; fullscreen" allowfullscreen style="width:100%; height:100%; border:none;"></iframe>
                        `;
                        playerOverlay.style.position = 'fixed';
                        playerOverlay.style.top = '0';
                        playerOverlay.style.left = '0';
                        playerOverlay.style.width = '100%';
                        playerOverlay.style.height = '100%';
                        playerOverlay.style.background = '#000';
                        playerOverlay.style.zIndex = '10000';
                        document.body.appendChild(playerOverlay);
                        document.body.classList.add('modal-open');

                        // Close button event
                        playerOverlay.querySelector('#close-full-player').addEventListener('click', () => {
                            playerOverlay.remove();
                            document.body.classList.remove('modal-open');
                        });
                    }
                    return; // Prevent opening the note modal
                }
                const card = e.target.closest('.note-card');
                if (card) {
                    const noteId = card.dataset.noteId;
                    const noteToEdit = notes.find(n => n.id === noteId);
                    if (noteToEdit) {
                        openNoteModal(noteToEdit);
                    }
                }
            });

            logo.addEventListener('click', (event) => {
                event.stopPropagation();
                appDropdown.style.display = appDropdown.style.display === 'block' ? 'none' : 'block';
            });
            window.addEventListener('click', () => {
                if (appDropdown.style.display === 'block') appDropdown.style.display = 'none';
            });

            // Real-time search as user types
            searchInput.addEventListener('input', (e) => {
                currentInputValue = e.target.value;
                renderNotes();
            });

            // Search functionality
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const term = searchInput.value.trim();
                    if (term) {
                        addSearchTag(term);
                        searchInput.value = '';
                        currentInputValue = '';
                        // Reset icon to search
                        const icon = document.querySelector('.search-icon');
                        icon.innerHTML = '<circle cx="11" cy="11" r="8" stroke="currentColor" stroke-width="2"/><path d="m21 21-4.35-4.35" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>';
                        icon.style.pointerEvents = 'none';
                        icon.style.cursor = 'default';
                        icon.onclick = null;
                    }
                } else if (e.key === 'Backspace' && searchInput.value === '' && searchTerms.length > 0) {
                    e.preventDefault();
                    const lastTerm = searchTerms[searchTerms.length - 1];

                    // Check if the last term is a type keyword
                    if (typeKeywords[lastTerm]) {
                        // For type tags, just remove completely
                        searchTerms.pop();
                        renderSearchTags();
                        renderNotes();
                    } else {
                        // For regular search tags, convert back to input text
                        searchTerms.pop(); // Remove last term
                        renderSearchTags();
                        searchInput.value = lastTerm;
                        currentInputValue = lastTerm;
                        renderNotes();
                        // Position cursor at the end
                        searchInput.focus();
                        searchInput.setSelectionRange(lastTerm.length, lastTerm.length);
                    }
                }
            });

            // Event delegation for search tag removal
            document.getElementById('searchTagsContainer').addEventListener('click', (e) => {
                if (e.target.classList.contains('search-tag-remove')) {
                    const index = parseInt(e.target.dataset.index);
                    removeSearchTag(index);
                }
            });

            // --- Create Modal Functions & Handlers ---
            function openCreateModal() {
                createNoteForm.reset(); // Clear form from previous use
                document.body.classList.add('modal-open');
                createNoteModal.style.display = 'flex';
            }

            function closeCreateModal() {
                createNoteModal.style.display = 'none';
                document.body.classList.remove('modal-open');
            }

            async function handleCreateNote(e) {
                e.preventDefault(); // Prevent default form submission
                const titleInput = document.getElementById('newNoteTitle');
                const contentInput = document.getElementById('newNoteContent');

                const title = titleInput.value.trim();
                const content = contentInput.value.trim();

                try {
                    const newNote = await api.createNote(title, content);
                    notes.unshift(newNote.note); // Add to the beginning of the array
                    saveNotesToCache(notes); // Update cache
                    renderNotes();
                    closeCreateModal();
                } catch (error) {
                    console.error('Create note failed:', error);
                    alert('Could not create the note. Please try again.');
                }
            }

            // --- Add listeners for create modal ---
            createNoteForm.addEventListener('submit', handleCreateNote);
            cancelCreateBtn.addEventListener('click', closeCreateModal);
            createNoteModal.addEventListener('click', (e) => {
                if (e.target === createNoteModal) {
                    closeCreateModal();
                }
            });

            // --- Initialization ---
            async function init() {
                try {
                    // Load cached notes first for instant display
                    const cachedNotes = loadNotesFromCache();
                    if (cachedNotes) {
                        notes = cachedNotes;
                        renderNotes();
                    }

                    // Then fetch fresh data from API
                    const freshNotes = await api.getNotes();
                    notes = freshNotes;
                    saveNotesToCache(notes);
                    renderNotes();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    // If API fails but we have cache, keep showing cached notes
                    if (notes.length === 0) {
                        notesContainer.innerHTML = '<p style="text-align:center; color:var(--danger-color);">Could not load notes.</p>';
                    }
                }
            }

            init();

            // --- Scroll-based search position ---
            window.addEventListener('scroll', () => {
                const searchSection = document.querySelector('.search-section');
                if (window.scrollY > 0) {
                    searchSection.style.top = '1rem';
                } else {
                    searchSection.style.top = '5rem';
                }
            });

            // --- Keyboard Shortcuts ---
            document.addEventListener('keydown', async (e) => {
                if (e.altKey && e.code === 'KeyS') {
                    e.preventDefault();
                    searchInput.focus();
                }
                if (e.altKey && e.code === 'KeyN') {
                    e.preventDefault();
                    // Close any open modals first
                    if (noteModal.style.display === 'flex') {
                        closeNoteModal();
                    } else if (createNoteModal.style.display === 'flex') {
                        closeCreateModal();
                    }
                    openCreateModal();
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !e.altKey && !e.shiftKey) {
                    // Check if we're not in an editable element (input, textarea, or contenteditable)
                    const activeElement = document.activeElement;
                    const isEditable = activeElement.tagName === 'INPUT' ||
                                       activeElement.tagName === 'TEXTAREA' ||
                                       activeElement.contentEditable === 'true';
                    if (!isEditable) {
                        e.preventDefault();
                        // Create note directly from clipboard content in background
                        (async () => {
                            try {
                                const text = await navigator.clipboard.readText();
                                if (text.trim()) {
                                    showNotification('Creating note from clipboard...');
                                    const newNote = await api.createNote('', text);
                                    notes.unshift(newNote.note); // Add to the beginning of the array
                                    saveNotesToCache(notes); // Update cache
                                    renderNotes();
                                    showNotification('Note created successfully!');
                                }
                            } catch (err) {
                                console.error('Failed to create note from clipboard:', err);
                                showNotification('Failed to create note from clipboard');
                            }
                        })();
                    }
                }
                if (e.key === 'Escape') {
                    if (noteModal.style.display === 'flex') {
                        closeNoteModal();
                    } else if (createNoteModal.style.display === 'flex') {
                        closeCreateModal();
                    } else if (profileModal.style.display === 'flex') {
                        profileModal.style.display = 'none';
                        profileForm.reset();
                    }
                }
            });

            // Profile Modal
            const profileBtn = document.getElementById('profileBtn');
            const profileModal = document.getElementById('profileModal');
            const profileForm = document.getElementById('profileForm');
            const cancelProfileBtn = document.getElementById('cancelProfileBtn');

            profileBtn.addEventListener('click', () => {
                profileModal.style.display = 'flex';
            });

            cancelProfileBtn.addEventListener('click', () => {
                profileModal.style.display = 'none';
                profileForm.reset();
            });

            profileModal.addEventListener('click', (e) => {
                if (e.target === profileModal) {
                    profileModal.style.display = 'none';
                    profileForm.reset();
                }
            });

            profileForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData();
                const imageFile = document.getElementById('profileImageInput').files[0];
                if (imageFile) formData.append('profile_image', imageFile);
                const username = document.getElementById('usernameInput').value;
                if (username) formData.append('username', username);
                const email = document.getElementById('emailInput').value;
                if (email) formData.append('email', email);
                const password = document.getElementById('passwordInput').value;
                if (password) formData.append('password', password);

                try {
                    const response = await fetch('/api/profile', { method: 'POST', body: formData });
                    if (response.ok) {
                        showNotification('Profile updated successfully!');
                        profileModal.style.display = 'none';
                        profileForm.reset();
                        window.location.reload(); // Reload to show updated profile image
                    } else {
                        showNotification('Failed to update profile.');
                    }
                } catch (error) {
                    console.error('Error updating profile:', error);
                    showNotification('Error updating profile.');
                }
            });

            // Close player modal on button click
            document.addEventListener('click', (event) => {
                if (event.target.closest('#close-player-btn')) {
                    closePlayerModal();
                }
            });
        });
    </script>
</body>
</html>