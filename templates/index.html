<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YAJORA - Tasks</title>
    <link rel="icon" type="image/png" href="{{ url_for('static', filename='favicon.png') }}">
    <!-- Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">

</head>

<body class="">
    <!-- Data div for initial tasks -->
    <div id="initial-data" data-tasks='{{ initial_tasks | tojson }}' style="display: none;"></div>

    <div class="container">
        <header>
            <div class="header-top">
                <div class="logo-container">
                    <svg class="logo" id="logo" width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z" fill="currentColor"/>
                        <path d="M12 12m-5 0a5 5 0 1 0 10 0a5 5 0 1 0-10 0" fill="currentColor" fill-opacity="0.5"/>
                    </svg>
                    <div class="menu" id="menu">
                        <a href="/~" class="menu-item active">Yajora Tasks</a>
                        <a href="/notes" class="menu-item">Yajora Notes</a>
                    </div>
                </div>
                <h1 id="headerTitle"></h1>
            </div>
            <div class="date-nav">
                <span class="nav-arrow" id="prevDayBtn">‹</span>
                <div class="date" id="currentDate"></div>
                <span class="nav-arrow" id="nextDayBtn">›</span>
            </div>
        </header>

        <!-- Progress Bar Element -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar-inner" id="progressBarInner"></div>
            <span class="progress-text" id="progressText"></span>
        </div>

        <div id="tasksContainer">
            <ul class="task-list" id="taskList"></ul>
        </div>

        <div id="analyticsContainer" style="display: none;">
            <!-- Motivation & Progress Analytics -->
            <div class="analytics-section">
                <h2>🔥 Motivation & Progress</h2>
                <div class="stats-grid">
                    <div class="stat-card streak-card">
                        <div class="value" id="currentStreakStat">0</div>
                        <div class="label">Current Streak</div>
                        <div class="sublabel">days of 100% completion</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="bestStreakStat">0</div>
                        <div class="label">Best Streak</div>
                        <div class="sublabel">personal record</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="weeklyCompletionStat">0%</div>
                        <div class="label">Weekly Rate</div>
                        <div class="sublabel">last 7 days</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="consistencyScoreStat">0%</div>
                        <div class="label">Consistency</div>
                        <div class="sublabel">regularity score</div>
                    </div>
                </div>
            </div>

            <!-- Productivity Insights -->
            <div class="analytics-section">
                <!-- REVISED: Commitment Calendar Section -->
                <div class="analytics-section">
                    <h2>🧱 THE WALL</h2>
                    <div class="commitment-calendar-card" id="commitmentCalendarContainer">
                        <!-- Calendar will be rendered here by JavaScript -->
                    </div>
                </div>
                <h2>📊 Productivity Insights</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="value" id="peakDayStat">-</div>
                        <div class="label">Peak Day</div>
                        <div class="sublabel">most productive</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="taskDifficultyStat">-</div>
                        <div class="label">Hardest Task</div>
                        <div class="sublabel">most skipped</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="momentumStat">0%</div>
                        <div class="label">Momentum</div>
                        <div class="sublabel">task completion flow</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="averageCompletionStat">0</div>
                        <div class="label">Daily Average</div>
                        <div class="sublabel">tasks per day</div>
                    </div>
                </div>
            </div>

            <!-- Goal-Oriented Metrics -->
            <div class="analytics-section">
                <h2>🎯 Goal Progress</h2>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="value" id="monthlyImprovementStat">0%</div>
                        <div class="label">Monthly Growth</div>
                        <div class="sublabel">vs last month</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="categoryPerformanceStat">-</div>
                        <div class="label">Best Category</div>
                        <div class="sublabel">highest completion</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="weeklyGoalsStat">0%</div>
                        <div class="label">Weekly Goals</div>
                        <div class="sublabel">planned vs actual</div>
                    </div>
                    <div class="stat-card">
                        <div class="value" id="totalHabitsStat">0</div>
                        <div class="label">Active Habits</div>
                        <div class="sublabel">in progress</div>
                    </div>
                </div>
            </div>

            <!-- Charts -->
            <div class="chart-container">
                <div class="chart-header">
                    <h2>Completion Trends</h2>
                    <div class="chart-time-selector" id="completionTrendSelector">
                        <button class="time-btn active" data-range="1M">1M</button>
                        <button class="time-btn" data-range="3M">3M</button>
                        <button class="time-btn" data-range="6M">6M</button>
                        <button class="time-btn" data-range="1Y">1Y</button>
                        <button class="time-btn" data-range="5Y">5Y</button>
                    </div>
                </div>
                <canvas id="completionTrendChart"></canvas>
            </div>
            <div class="chart-container">
                <h2>Weekly Performance</h2>
                <canvas id="weeklyPerformanceChart"></canvas>
            </div>

            <!-- Data Management -->
            <div class="data-management-card">
                <h2>Data & Account</h2>
                <div class="welcome-message" id="welcomeMessage"></div>
                <div class="data-actions">
                    <button id="importBtn">Import Data</button>
                    <button id="exportBtn">Export Data</button>
                    <button id="logoutBtn" class="btn-danger">Logout</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Action Button -->
    <div class="add-task-btn" id="addTaskBtn">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      </svg>
    </div>

    <!-- Modals and Inputs -->
    <input type="file" id="importFileInput" style="display: none;" accept="application/json">
    <div class="modal" id="taskModal">
        <div class="modal-content"><input type="text" id="taskInput" placeholder="Enter task"><select id="groupSelect"></select><input type="text" id="newGroupInput" placeholder="Enter new group name" style="display: none;">
            <div class="task-type-selection">
                <button class="task-type-btn selected" id="oneTimeBtn">One-time</button>
                <button class="task-type-btn" id="repetitiveBtn">Repetitive</button>
            </div>
            <div class="days-selection" id="daysSelection" style="display: none;">
                <button class="day-btn" data-day="Daily">Daily</button><button class="day-btn" data-day="Mo">Mo</button><button class="day-btn" data-day="Tu">Tu</button><button class="day-btn" data-day="We">We</button><button class="day-btn" data-day="Th">Th</button><button class="day-btn" data-day="Fr">Fr</button><button class="day-btn" data-day="Sa">Sa</button><button class="day-btn" data-day="Su">Su</button>
            </div>
            <div class="modal-actions"><button class="btn-danger" id="deleteBtn" style="display: none;">Delete Task</button><button id="cancelBtn">Cancel</button><button id="saveBtn">Save</button></div>
        </div>
    </div>
    <div class="modal" id="deleteGroupModal">
        <div class="modal-content">
            <p id="deleteGroupModalText"></p>
            <div class="modal-actions"><button id="cancelDeleteGroupBtn">Cancel</button><button id="confirmDeleteGroupBtn" class="btn-danger">Confirm Delete</button></div>
        </div>
    </div>
    <div class="modal" id="categoryModal">
        <div class="modal-content">
            <input type="text" id="categoryInput" placeholder="Enter category name">
            <div class="modal-actions">
                <button id="cancelCategoryBtn">Cancel</button>
                <button id="deleteCategoryBtn" class="btn-danger">Delete</button>
                <button id="saveCategoryBtn">Save</button>
            </div>
        </div>
    </div>
    <div class="modal" id="habitGoalModal">
        <div class="modal-content">
            <h3>Set Habit Goal</h3>
            <p id="habitInfoText"></p>
            <div class="form-grid">
                <div class="form-group">
                    <label for="habitStartDateInput">Start Date:</label>
                    <input type="date" id="habitStartDateInput">
                </div>
                <div class="form-group">
                    <label for="habitGoalInput">Goal (days):</label>
                    <input type="number" id="habitGoalInput" placeholder="e.g., 21" min="1">
                </div>
            </div>
            <div id="habitEndDateContainer">
                <strong>End Date:</strong> <span id="habitEndDateDisplay">-</span>
            </div>
            <div class="modal-actions"><button id="cancelHabitGoalBtn">Cancel</button><button id="saveHabitGoalBtn">Save Goal</button></div>
        </div>
    </div>

    <script>
        // DOM Elements
        const headerTitle = document.querySelector('.header-top h1'); const tasksContainer = document.getElementById('tasksContainer'); const analyticsContainer = document.getElementById('analyticsContainer'); const taskList = document.getElementById('taskList'); const addTaskBtn = document.getElementById('addTaskBtn'); const dateNav = document.querySelector('.date-nav'); const currentDateElement = document.getElementById('currentDate'); const prevDayBtn = document.getElementById('prevDayBtn'); const nextDayBtn = document.getElementById('nextDayBtn'); const taskModal = document.getElementById('taskModal'); const taskInput = document.getElementById('taskInput'); const saveBtn = document.getElementById('saveBtn'); const cancelBtn = document.getElementById('cancelBtn'); const deleteBtn = document.getElementById('deleteBtn'); const daysSelection = document.getElementById('daysSelection'); const groupSelect = document.getElementById('groupSelect'); const newGroupInput = document.getElementById('newGroupInput'); const deleteGroupModal = document.getElementById('deleteGroupModal'); const deleteGroupModalText = document.getElementById('deleteGroupModalText'); const cancelDeleteGroupBtn = document.getElementById('cancelDeleteGroupBtn'); const confirmDeleteGroupBtn = document.getElementById('confirmDeleteGroupBtn'); const importBtn = document.getElementById('importBtn'); const exportBtn = document.getElementById('exportBtn'); const importFileInput = document.getElementById('importFileInput'); const habitGoalModal = document.getElementById('habitGoalModal'); const habitInfoText = document.getElementById('habitInfoText'); const habitGoalInput = document.getElementById('habitGoalInput'); const saveHabitGoalBtn = document.getElementById('saveHabitGoalBtn'); const cancelHabitGoalBtn = document.getElementById('cancelHabitGoalBtn'); const logoutBtn = document.getElementById('logoutBtn'); const welcomeMessage = document.getElementById('welcomeMessage'); const categoryModal = document.getElementById('categoryModal'); const categoryInput = document.getElementById('categoryInput'); const cancelCategoryBtn = document.getElementById('cancelCategoryBtn'); const deleteCategoryBtn = document.getElementById('deleteCategoryBtn'); const saveCategoryBtn = document.getElementById('saveCategoryBtn');
        const progressContainer = document.getElementById('progressContainer'); const progressBarInner = document.getElementById('progressBarInner'); const progressText = document.getElementById('progressText');
        const oneTimeBtn = document.getElementById('oneTimeBtn'); const repetitiveBtn = document.getElementById('repetitiveBtn');
        const habitStartDateInput = document.getElementById('habitStartDateInput'); const habitEndDateDisplay = document.getElementById('habitEndDateDisplay');

        // State
        const initialDataEl = document.getElementById('initial-data');
        let tasks = JSON.parse(initialDataEl.dataset.tasks);
        let currentDisplayDate = new Date(); let editingTaskId = null; let editingHabitTaskId = null; let editingGroup = null; let groupToDelete = null; let completionTrendChart = null; let weeklyPerformanceChart = null;
        let completionTrendRange = '1M'; // Default time range

        // --- REAL-TIME SERVER COMMUNICATION (WebSocket) ---
        const socket = io();
        let isSyncing = false; let syncTimeout;
        socket.on('tasks_updated', (updatedTasks) => { console.log('Received real-time task update from server.'); tasks = updatedTasks; if (tasksContainer.style.display === 'block' || tasksContainer.style.display === '') { renderTasks(); updateProgressBar(); } if (analyticsContainer.style.display === 'block') { renderAnalytics(); } });
        socket.on('connect', () => { console.log('WebSocket connected!'); });
        socket.on('disconnect', () => { console.log('WebSocket disconnected.'); });
        async function syncTasksToServer() { clearTimeout(syncTimeout); syncTimeout = setTimeout(async () => { if (isSyncing) return; isSyncing = true; try { const response = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(tasks) }); if (!response.ok) throw new Error('Sync failed'); } catch (error) { console.error("Failed to sync tasks:", error); } finally { isSyncing = false; } }, 200); }
        async function handleLogout() { try { const response = await fetch('/logout', { method: 'POST' }); const result = await response.json(); if (response.ok) { window.location.href = result.redirect || '/'; } else { alert('Logout failed.'); } } catch (error) { alert('Could not connect to the server to log out.'); } }

        // --- VIEW SWITCHING, ANALYTICS, DATA-MGMT ---
        function showTasksView() { document.body.classList.remove('analytics-active'); tasksContainer.style.display = 'block'; analyticsContainer.style.display = 'none'; dateNav.style.visibility = 'visible'; progressContainer.style.display = 'block'; addTaskBtn.style.display = 'flex'; headerTitle.textContent = 'Tasks'; updateView(); }
        function showAnalyticsView() { document.body.classList.add('analytics-active'); tasksContainer.style.display = 'none'; analyticsContainer.style.display = 'block'; dateNav.style.visibility = 'hidden'; progressContainer.style.display = 'none'; addTaskBtn.style.display = 'none'; headerTitle.textContent = 'Analytics'; renderAnalytics(); }
        function renderAnalytics() {
            const analytics = calculateComprehensiveAnalytics();
            document.getElementById('currentStreakStat').textContent = analytics.currentStreak;
            document.getElementById('bestStreakStat').textContent = analytics.bestStreak;
            document.getElementById('weeklyCompletionStat').textContent = analytics.weeklyCompletion + '%';
            document.getElementById('consistencyScoreStat').textContent = analytics.consistencyScore + '%';
            document.getElementById('peakDayStat').textContent = analytics.peakDay;
            document.getElementById('taskDifficultyStat').textContent = analytics.hardestTask;
            document.getElementById('momentumStat').textContent = analytics.momentum + '%';
            document.getElementById('averageCompletionStat').textContent = analytics.dailyAverage;
            document.getElementById('monthlyImprovementStat').textContent = analytics.monthlyImprovement + '%';
            document.getElementById('categoryPerformanceStat').textContent = analytics.bestCategory;
            document.getElementById('weeklyGoalsStat').textContent = analytics.weeklyGoals + '%';
            document.getElementById('totalHabitsStat').textContent = analytics.activeHabits;
            renderCommitmentCalendar();
            renderLineChart(calculateCompletionTrend(completionTrendRange));
            renderWeeklyPerformanceChart(analytics.weeklyData);
        }

        // --- COMMITMENT CALENDAR (GRID LAYOUT) RENDER FUNCTION ---
        function renderCommitmentCalendar() {
            const container = document.getElementById('commitmentCalendarContainer');
            if (!container) return;
            container.innerHTML = '';

            const calendarData = new Map();
            const today = new Date();
            const endDate = new Date(today);
            const startDate = new Date(today);
            startDate.setDate(today.getDate() - 364);
            while (startDate.getDay() !== 0) { // Start on a Sunday for alignment
                startDate.setDate(startDate.getDate() - 1);
            }

            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = formatDateString(d);
                const dayTasks = getTasksForDate(d);
                let level = 0, completedCount = 0, totalCount = 0, percentage = 0;
                if (dayTasks.length > 0) {
                    totalCount = dayTasks.length;
                    completedCount = dayTasks.filter(task => task.completedOn[dateStr]).length;
                    percentage = Math.round((completedCount / totalCount) * 100);
                    if (percentage === 100) level = 4;
                    else if (percentage >= 51) level = 3;
                    else if (percentage >= 26) level = 2;
                    else if (percentage >= 1) level = 1;
                }
                calendarData.set(dateStr, { level, completedCount, totalCount, percentage });
            }

            const todayStr = formatDateString(today);
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            let monthHeadersHTML = '';
            let lastMonth = -1;

            for (let i = 0; i < 53; i++) {
                const weekStartDate = new Date(startDate);
                weekStartDate.setDate(startDate.getDate() + (i * 7));
                const month = weekStartDate.getMonth();
                if (month !== lastMonth && (weekStartDate.getDate() < 8 || i === 0)) {
                    monthHeadersHTML += `<div class="calendar-months-item" style="grid-column: ${i + 1};">${monthNames[month]}</div>`;
                    lastMonth = month;
                }
            }
            
            let bricksHTML = '';
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateStr = formatDateString(d);
                const data = calendarData.get(dateStr) || { level: 0, completedCount: 0, totalCount: 0 };
                const isTodayClass = (dateStr === todayStr) ? 'is-today' : '';
                const tooltipText = (data.totalCount > 0)
                    ? `${d.toLocaleDateString('en-US', {dateStyle: 'long'})}: ${data.completedCount}/${data.totalCount} tasks`
                    : `${d.toLocaleDateString('en-US', {dateStyle: 'long'})}: No tasks`;
                bricksHTML += `<div class="brick status-level-${data.level} ${isTodayClass}"><span class="tooltip">${tooltipText}</span></div>`;
            }

            container.innerHTML = `
                <div class="calendar-header">${monthHeadersHTML}</div>
                <div class="calendar-body">
                    <div class="calendar-days-labels">
                        <div class="calendar-days-label"></div><div class="calendar-days-label">Mon</div><div class="calendar-days-label"></div><div class="calendar-days-label">Wed</div><div class="calendar-days-label"></div><div class="calendar-days-label">Fri</div><div class="calendar-days-label"></div>
                    </div>
                    <div class="calendar-grid">${bricksHTML}</div>
                </div>
                <div class="calendar-legend">
                    Less
                    <div class="legend-item" style="background-color: var(--brick-color-level-0);"></div><div class="legend-item" style="background-color: var(--brick-color-level-1);"></div><div class="legend-item" style="background-color: var(--brick-color-level-2);"></div><div class="legend-item" style="background-color: var(--brick-color-level-3);"></div><div class="legend-item" style="background-color: var(--brick-color-level-4);"></div>
                    More
                </div>`;
        }

        // --- ALL OTHER JS FUNCTIONS (UNCHANGED) ---
        function countTaskOpportunities(task) {
            if (!task.creationDate) return 0;

            const creationDate = new Date(task.creationDate + 'T00:00:00');
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let opportunities = 0;
            const daysOfWeek = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

            // Determine the end date for counting
            let endDate = today;
            if (task.habitTracker && task.habitTracker.goal) {
                const habitEndDate = new Date(creationDate);
                habitEndDate.setDate(creationDate.getDate() + task.habitTracker.goal);
                if (habitEndDate < today) {
                    endDate = habitEndDate;
                }
            }

            if (task.isOneTime) {
                // A one-time task only has an opportunity if its specific date is on or before today.
                if (task.date) {
                    const taskDate = new Date(task.date + 'T00:00:00');
                    if (taskDate <= today) {
                        return 1;
                    }
                }
                return 0;
            }

            // For recurring tasks, iterate from creation to end date
            let currentDate = new Date(creationDate);
            while (currentDate <= endDate) {
                const dayOfWeek = daysOfWeek[currentDate.getDay()];
                if (task.recurrence.includes('Daily') || task.recurrence.includes(dayOfWeek)) {
                    opportunities++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }

            return opportunities;
        }
        function calculateCompletionTrend(range) {
            let numDays;
            switch (range) {
                case '1M': numDays = 30; break;
                case '3M': numDays = 90; break;
                case '6M': numDays = 180; break;
                case '1Y': numDays = 365; break;
                case '5Y': numDays = 365 * 5; break;
                default: numDays = 30;
            }
            const labels = []; const data = new Array(numDays).fill(0); for (let i = numDays - 1; i >= 0; i--) { const d = new Date(); d.setUTCHours(0, 0, 0, 0); d.setDate(d.getDate() - i); const dateString = formatDateString(d); labels.push(d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })); const dayTasks = getTasksForDate(d); const completedTasks = dayTasks.filter(task => task.completedOn[dateString] === true); const percentage = dayTasks.length > 0 ? Math.round((completedTasks.length / dayTasks.length) * 100) : 0; data[numDays - 1 - i] = percentage; } return { labels, data };
         }
        function calculateComprehensiveAnalytics() { return { currentStreak: calculateCurrentStreak(), bestStreak: calculateBestStreak(), weeklyCompletion: calculateWeeklyCompletion(), consistencyScore: calculateConsistencyScore(), peakDay: calculatePeakDay(), hardestTask: calculateHardestTask(), momentum: calculateMomentum(), dailyAverage: calculateDailyAverage(), monthlyImprovement: calculateMonthlyImprovement(), bestCategory: calculateBestCategory(), weeklyGoals: calculateWeeklyGoals(), activeHabits: calculateActiveHabits(), weeklyData: calculateWeeklyData() }; }
        function calculateCurrentStreak() { let streak = 0; const today = new Date(); for (let i = 0; i < 365; i++) { const checkDate = new Date(today); checkDate.setDate(checkDate.getDate() - i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); if (dayTasks.length === 0) { if (i === 0) continue; else break; } const completedTasks = dayTasks.filter(task => task.completedOn[dateString] === true); if (completedTasks.length === dayTasks.length) { streak++; } else { break; } } return streak; }
        function calculateBestStreak() { let bestStreak = 0; let currentStreak = 0; for (let i = 364; i >= 0; i--) { const checkDate = new Date(); checkDate.setDate(checkDate.getDate() - i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); if (dayTasks.length === 0) { currentStreak = 0; continue; } const completedTasks = dayTasks.filter(task => task.completedOn[dateString] === true); if (completedTasks.length === dayTasks.length) { currentStreak++; } else { currentStreak = 0; } bestStreak = Math.max(bestStreak, currentStreak); } return bestStreak; }
        function calculateWeeklyCompletion() { let totalTasks = 0, completedTasks = 0; for (let i = 0; i < 7; i++) { const checkDate = new Date(); checkDate.setDate(checkDate.getDate() - i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); totalTasks += dayTasks.length; completedTasks += dayTasks.filter(task => task.completedOn[dateString] === true).length; } return totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0; }
        function calculateConsistencyScore() { let daysWithTasks = 0, daysCompleted = 0; for (let i = 0; i < 30; i++) { const checkDate = new Date(); checkDate.setDate(checkDate.getDate() - i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); if (dayTasks.length > 0) { daysWithTasks++; const completed = dayTasks.filter(task => task.completedOn[dateString] === true); if (completed.length > 0) daysCompleted++; } } return daysWithTasks > 0 ? Math.round((daysCompleted / daysWithTasks) * 100) : 0; }
        function calculatePeakDay() { const dayCounts = { 'Su': 0, 'Mo': 0, 'Tu': 0, 'We': 0, 'Th': 0, 'Fr': 0, 'Sa': 0 }; const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; tasks.forEach(task => { Object.keys(task.completedOn).forEach(dateStr => { if (task.completedOn[dateStr]) { const d = new Date(dateStr); const dayOfWeek = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'][d.getUTCDay()]; dayCounts[dayOfWeek]++; } }); }); const peakDay = Object.keys(dayCounts).reduce((a, b) => dayCounts[a] > dayCounts[b] ? a : b); const dayIndex = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'].indexOf(peakDay); return dayNames[dayIndex] || '-'; }
        function calculateHardestTask() {
            let hardestTask = '-';
            let lowestCompletion = 100;

            tasks.forEach(task => {
                // Use the new helper function to get accurate opportunity count
                const totalOpportunities = countTaskOpportunities(task);
                const completions = Object.values(task.completedOn).filter(Boolean).length;

                // Only consider tasks with a history
                if (totalOpportunities > 0) {
                    const completionRate = (completions / totalOpportunities) * 100;
                    if (completionRate < lowestCompletion) {
                        lowestCompletion = completionRate;
                        hardestTask = task.text.length > 15 ? task.text.substring(0, 15) + '...' : task.text;
                    }
                }
            });

            return hardestTask;
        }
        function calculateMomentum() { const today = new Date(); const dateString = formatDateString(today); const todayTasks = getTasksForDate(today); if (todayTasks.length === 0) return 0; const completedToday = todayTasks.filter(task => task.completedOn[dateString] === true).length; return Math.round((completedToday / todayTasks.length) * 100); }
        function calculateDailyAverage() { let totalCompleted = 0, daysCount = 0; for (let i = 0; i < 30; i++) { const checkDate = new Date(); checkDate.setDate(checkDate.getDate() - i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); if (dayTasks.length > 0) { daysCount++; totalCompleted += dayTasks.filter(task => task.completedOn[dateString] === true).length; } } return daysCount > 0 ? Math.round(totalCompleted / daysCount) : 0; }
        function calculateMonthlyImprovement() { const thisMonth = calculateMonthCompletion(0); const lastMonth = calculateMonthCompletion(1); if (lastMonth === 0) return 0; return Math.round(((thisMonth - lastMonth) / lastMonth) * 100); }
        function calculateMonthCompletion(monthsAgo) { let totalTasks = 0, completedTasks = 0; const startDate = new Date(); startDate.setMonth(startDate.getMonth() - monthsAgo, 1); const endDate = new Date(startDate); endDate.setMonth(endDate.getMonth() + 1, 0); for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) { const dateString = formatDateString(d); const dayTasks = getTasksForDate(d); totalTasks += dayTasks.length; completedTasks += dayTasks.filter(task => task.completedOn[dateString] === true).length; } return totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0; }
        function calculateBestCategory() {
            const categoryStats = {};

            tasks.forEach(task => {
                const category = task.group || 'Ungrouped';
                if (!categoryStats[category]) {
                    categoryStats[category] = { opportunities: 0, completions: 0 };
                }
                // Use the new helper function for accuracy
                categoryStats[category].opportunities += countTaskOpportunities(task);
                categoryStats[category].completions += Object.values(task.completedOn).filter(Boolean).length;
            });

            let bestCategory = '-';
            let bestRate = -1; // Start at -1 to ensure any category with a rate > -1 is chosen

            Object.keys(categoryStats).forEach(category => {
                const { opportunities, completions } = categoryStats[category];
                if (opportunities > 0) {
                    const rate = (completions / opportunities) * 100;
                    if (rate > bestRate) {
                        bestRate = rate;
                        bestCategory = category;
                    }
                }
            });

            return bestCategory;
        }
        function calculateWeeklyGoals() { return calculateWeeklyCompletion(); }
        function calculateActiveHabits() { return tasks.filter(task => task.recurrence.includes('Daily')).length; }
        function calculateWeeklyData() { const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']; const data = []; const today = new Date(); today.setHours(0, 0, 0, 0); const dayOfWeek = today.getDay(); const daysSinceMonday = (dayOfWeek + 6) % 7; const monday = new Date(today); monday.setDate(today.getDate() - daysSinceMonday); for (let i = 0; i < 7; i++) { const checkDate = new Date(monday); checkDate.setDate(monday.getDate() + i); const dateString = formatDateString(checkDate); const dayTasks = getTasksForDate(checkDate); const completedTasks = dayTasks.filter(task => task.completedOn[dateString] === true); const percentage = dayTasks.length > 0 ? Math.round((completedTasks.length / dayTasks.length) * 100) : 0; data.push(percentage); } return { labels, data }; }
        function renderLineChart(chartData) { const ctx = document.getElementById('completionTrendChart').getContext('2d'); if (completionTrendChart) completionTrendChart.destroy(); completionTrendChart = new Chart(ctx, { type: 'line', data: { labels: chartData.labels, datasets: [{ label: 'Completion Percentage', data: chartData.data, backgroundColor: 'rgba(249, 115, 22, 0.15)', borderColor: '#F97316', borderWidth: 3, tension: 0.4, fill: true, pointBackgroundColor: '#F97316', pointBorderColor: '#fff', pointBorderWidth: 2, pointRadius: 6, pointHoverRadius: 8 }] }, options: { responsive: true, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: value => value + '%' } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: context => `${context.parsed.y}% completed ${getTrendText(context.dataIndex, chartData.data)}` } } } } }); }
        function getTrendText(index, data) { if (index === 0) return ''; const difference = data[index] - data[index - 1]; if (Math.abs(difference) <= 2) return '(stable)'; if (difference > 0) return `(+${difference.toFixed(0)}%)`; return `(${difference.toFixed(0)}%)`; }
        function renderWeeklyPerformanceChart(weeklyData) { const ctx = document.getElementById('weeklyPerformanceChart').getContext('2d'); if (weeklyPerformanceChart) { weeklyPerformanceChart.destroy(); } weeklyPerformanceChart = new Chart(ctx, { type: 'bar', data: { labels: weeklyData.labels, datasets: [{ label: 'Completion Percentage', data: weeklyData.data, backgroundColor: weeklyData.data.map(percentage => { if (percentage === 100) return '#81C784'; else if (percentage >= 75) return '#AED581'; else if (percentage >= 50) return '#FFD54F'; else if (percentage >= 25) return '#FFB74D'; else if (percentage > 0) return '#E57373'; else return '#EEEEEE'; }), borderRadius: 8 }] }, options: { responsive: true, animation: false, scales: { y: { beginAtZero: true, max: 100, ticks: { stepSize: 20, callback: value => value + '%' } } }, plugins: { legend: { display: false }, tooltip: { callbacks: { label: context => `${context.parsed.y}% completed` } } } } }); }
        function formatDateString(date) { const d = new Date(date); const year = d.getFullYear(); const month = (d.getMonth() + 1).toString().padStart(2, '0'); const day = d.getDate().toString().padStart(2, '0'); return `${year}-${month}-${day}`; }
        function getTasksForDate(date) {
            const { dayOfWeek, dateString } = getDateInfo(date);
            const viewDate = new Date(date);
            viewDate.setHours(0, 0, 0, 0);

            return tasks.filter(task => {
                if (task.creationDate) {
                    // Ensure creationDate is parsed as local midnight to avoid timezone issues
                    const creationDate = new Date(task.creationDate + 'T00:00:00');
                    if (viewDate < creationDate) {
                        return false;
                    }
                }

                if (task.isOneTime) {
                    return task.date === dateString;
                }

                if (task.habitTracker && task.habitTracker.goal && task.creationDate) {
                    const creationDate = new Date(task.creationDate + 'T00:00:00');
                    const expiryDate = new Date(creationDate);
                    expiryDate.setDate(creationDate.getDate() + task.habitTracker.goal);
                    if (viewDate >= expiryDate) {
                        return false;
                    }
                }

                return task.recurrence.includes('Daily') || task.recurrence.includes(dayOfWeek);
            });
        }
        function updateView() { const dateInfo = getDateInfo(currentDisplayDate); currentDateElement.textContent = dateInfo.formatted; renderTasks(); updateProgressBar(); }
        function getDateInfo(date) { const days = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']; const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']; const dayOfWeek = days[date.getDay()]; const day = date.getDate(); const month = months[date.getMonth()]; const year = date.getFullYear(); const today = new Date(); today.setHours(0, 0, 0, 0); const compareDate = new Date(date); compareDate.setHours(0, 0, 0, 0); const isToday = compareDate.getTime() === today.getTime(); const isFuture = compareDate.getTime() > today.getTime(); let formattedDate = `${dayOfWeek}, ${month} ${day}`; if (!isToday) { formattedDate += `, ${year}`; } else { formattedDate += " (Today)"; } const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; return { dayOfWeek, dateString, formatted: formattedDate, isToday, isFuture }; }
        function updateProgressBar() { const dateInfo = getDateInfo(currentDisplayDate); const tasksForDay = getTasksForDate(currentDisplayDate); if (tasksForDay.length === 0) { progressContainer.style.display = 'none'; return; } progressContainer.style.display = 'block'; const completedTasks = tasksForDay.filter(task => task.completedOn[dateInfo.dateString] === true); const percentage = tasksForDay.length > 0 ? Math.round((completedTasks.length / tasksForDay.length) * 100) : 0; progressBarInner.style.width = `${percentage}%`; progressText.textContent = `${percentage}% Complete`; progressBarInner.className = 'progress-bar-inner'; if (percentage === 100) progressBarInner.classList.add('color-green'); else if (percentage >= 75) progressBarInner.classList.add('color-light-green'); else if (percentage >= 50) progressBarInner.classList.add('color-yellow'); else if (percentage >= 25) progressBarInner.classList.add('color-orange'); else if (percentage > 0) progressBarInner.classList.add('color-red'); }
        function findMostRecentPreviousDueDate(task, currentDate) {
            if (task.isOneTime || !task.creationDate) return null;

            const creationDate = new Date(task.creationDate);
            creationDate.setHours(0, 0, 0, 0);

            let checkDate = new Date(currentDate);
            checkDate.setDate(currentDate.getDate() - 1);
            checkDate.setHours(0, 0, 0, 0);

            // Don't check for due dates before the task was even created.
            if (checkDate < creationDate) {
                return null;
            }

            for (let i = 0; i < 365; i++) {
                // Stop if we go past the creation date.
                if (checkDate < creationDate) {
                    break;
                }
                const { dayOfWeek } = getDateInfo(checkDate);
                if (task.recurrence.includes('Daily') || task.recurrence.includes(dayOfWeek)) {
                    return checkDate; // Found the most recent previous due date.
                }
                checkDate.setDate(checkDate.getDate() - 1);
            }
            return null; // No previous due date found since creation.
        }
        function renderTasks() {
            const dateInfo = getDateInfo(currentDisplayDate);
            taskList.innerHTML = '';
            const groupedTasks = {};
            const tasksForDay = getTasksForDate(currentDisplayDate);
            if (tasksForDay.length === 0) {
                taskList.innerHTML = '<p style="text-align:center; color:#888; margin-top:2rem;">No tasks for this day.</p>';
                return;
            }
            tasksForDay.forEach(task => {
                const group = task.group || 'Ungrouped';
                if (!groupedTasks[group]) groupedTasks[group] = [];
                groupedTasks[group].push(task);
            });
            Object.keys(groupedTasks).sort((a, b) => a === 'Ungrouped' ? 1 : b === 'Ungrouped' ? -1 : a.localeCompare(b)).forEach(group => {
                const groupHeader = document.createElement('li');
                groupHeader.className = 'group-header';
                groupHeader.textContent = group;
                if (group !== 'Ungrouped') {
                    groupHeader.classList.add('deletable');
                    groupHeader.dataset.group = group;
                }
                taskList.appendChild(groupHeader);
                groupedTasks[group].forEach(task => {
                    const isCompletedToday = task.completedOn[dateInfo.dateString] === true;
                    const li = document.createElement('li');
                    li.className = 'task-item';
                    if (isCompletedToday) li.classList.add('completed');
                    li.dataset.taskId = task.id;

                    // Corrected Logic for missed tasks: Only apply if the task is not completed and the date is not in the future.
                    if (!isCompletedToday && !dateInfo.isFuture) {
                        const previousDueDate = findMostRecentPreviousDueDate(task, currentDisplayDate);
                        if (previousDueDate) {
                            const { dateString: prevDateString } = getDateInfo(previousDueDate);
                            if (task.completedOn[prevDateString] !== true) {
                                li.classList.add('missed-yesterday');
                            }
                        }
                    }

                    let habitHTML = '';
                    if (task.habitTracker) {
                        const { completedDates, goal } = task.habitTracker;
                        const count = completedDates.length;
                        if (count >= 90) {
                            habitHTML = `<span class="habit-formed">✔️ Habit Formed</span>`;
                        } else {
                            habitHTML = `<span class="habit-tracker" data-task-id="${task.id}">${count}/${goal}</span>`;
                        }
                    }
                    li.innerHTML = `<input type="checkbox" class="task-checkbox" ${isCompletedToday ? 'checked' : ''}><span class="task-text">${task.text}</span><div class="task-meta">${habitHTML}</div>`;
                    li.querySelector('.task-checkbox').addEventListener('change', e => {
                        e.stopPropagation();
                        toggleTaskCompletion(task.id, dateInfo.dateString);
                    });
                    li.addEventListener('click', e => {
                        if (e.target.type !== 'checkbox' && !e.target.classList.contains('habit-tracker')) openEditModal(task);
                    });
                    taskList.appendChild(li);
                });
            });
        }
        function toggleTaskCompletion(taskId, dateString) { const task = tasks.find(t => t.id === taskId); if (!task) return; task.completedOn[dateString] = task.completedOn[dateString] !== true; if (task.habitTracker) { const isCompletedNow = task.completedOn[dateString]; const dateIndex = task.habitTracker.completedDates.indexOf(dateString); if (isCompletedNow && dateIndex === -1) { task.habitTracker.completedDates.push(dateString); } else if (!isCompletedNow && dateIndex > -1) { task.habitTracker.completedDates.splice(dateIndex, 1); } const { completedDates, goal } = task.habitTracker; if (isCompletedNow && completedDates.length === goal) { if (goal === 21) task.habitTracker.goal = 45; else if (goal === 45) task.habitTracker.goal = 90; } } syncTasksToServer(); renderTasks(); updateProgressBar(); if (analyticsContainer.style.display === 'block') { renderAnalytics(); } }
        function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => { const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }
        function populateGroupDropdown() { const existingGroups = [...new Set(tasks.map(t => t.group).filter(Boolean))]; groupSelect.innerHTML = '<option value="">Ungrouped</option>'; existingGroups.sort().forEach(group => { groupSelect.innerHTML += `<option value="${group}">${group}</option>` }); groupSelect.innerHTML += '<option value="--add-new--">Create New Group...</option>'; }
        function openTaskModal() { taskModal.style.display = 'flex'; taskInput.focus(); populateGroupDropdown(); }
        function closeTaskModal() {
            taskModal.style.display = 'none';
            taskInput.value = '';
            editingTaskId = null;
            deleteBtn.style.display = 'none';
            document.querySelectorAll('.day-btn').forEach(btn => btn.classList.remove('selected'));
            newGroupInput.style.display = 'none';
            newGroupInput.value = '';
            groupSelect.value = '';
            oneTimeBtn.classList.add('selected');
            repetitiveBtn.classList.remove('selected');
            daysSelection.style.display = 'none';
        }
        function openEditModal(task) {
            editingTaskId = task.id;
            taskInput.value = task.text;
            if (task.isOneTime) {
                oneTimeBtn.classList.add('selected');
                repetitiveBtn.classList.remove('selected');
                daysSelection.style.display = 'none';
                document.querySelectorAll('.day-btn').forEach(btn => btn.classList.remove('selected'));
            } else {
                repetitiveBtn.classList.add('selected');
                oneTimeBtn.classList.remove('selected');
                daysSelection.style.display = 'grid';
                document.querySelectorAll('.day-btn').forEach(btn => btn.classList.toggle('selected', task.recurrence.includes(btn.dataset.day)));
            }
            deleteBtn.style.display = 'inline-block';
            openTaskModal();
            groupSelect.value = task.group || '';
        }
        function updateEndDateDisplay() {
            const startDateValue = habitStartDateInput.value;
            const goalValue = parseInt(habitGoalInput.value, 10);
            if (startDateValue && !isNaN(goalValue) && goalValue > 0) {
                const startDate = new Date(startDateValue + 'T00:00:00');
                const endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + goalValue - 1);
                habitEndDateDisplay.textContent = endDate.toLocaleDateString('en-US', { dateStyle: 'long' });
            } else {
                habitEndDateDisplay.textContent = '-';
            }
        }
        function openHabitGoalModal(taskId) {
            editingHabitTaskId = taskId;
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            habitGoalInput.value = task.habitTracker.goal;
            habitStartDateInput.value = task.creationDate ? task.creationDate.split('T')[0] : formatDateString(new Date());
            habitInfoText.textContent = `Current progress for "${task.text}" is ${task.habitTracker.completedDates.length} days.`;
            habitStartDateInput.addEventListener('input', updateEndDateDisplay);
            habitGoalInput.addEventListener('input', updateEndDateDisplay);
            updateEndDateDisplay();
            habitGoalModal.style.display = 'flex';
            habitGoalInput.focus();
        }
        function closeHabitGoalModal() {
            habitGoalModal.style.display = 'none';
            habitGoalInput.value = '';
            habitStartDateInput.value = '';
            habitEndDateDisplay.textContent = '-';
            editingHabitTaskId = null;
            habitStartDateInput.removeEventListener('input', updateEndDateDisplay);
            habitGoalInput.removeEventListener('input', updateEndDateDisplay);
        }
        function saveHabitGoal() {
            const task = tasks.find(t => t.id === editingHabitTaskId);
            if (!task) return;

            const newGoal = parseInt(habitGoalInput.value, 10);
            const newStartDate = habitStartDateInput.value;

            // Validation
            const currentCount = task.habitTracker.completedDates.length;
            if (isNaN(newGoal) || newGoal <= 0) {
                alert("Please enter a valid goal greater than zero.");
                return;
            }
            if (!newStartDate) {
                alert("Please select a valid start date.");
                return;
            }
            const tempStartDate = new Date(newStartDate + 'T00:00:00');
            const earliestPossibleStartDate = new Date(task.creationDate + 'T00:00:00');
            earliestPossibleStartDate.setDate(earliestPossibleStartDate.getDate() - (task.habitTracker.completedDates.length > 0 ? task.habitTracker.completedDates.length - 1 : 0));

            // Update task properties
            task.habitTracker.goal = newGoal;
            task.creationDate = newStartDate;

            syncTasksToServer();
            closeHabitGoalModal();
            updateView();
        }
        function saveTask() {
            const text = taskInput.value.trim();
            if (!text) {
                alert('Task text is required.');
                return;
            }
            const isRepetitive = repetitiveBtn.classList.contains('selected');
            let group = (groupSelect.value === '--add-new--') ? newGroupInput.value.trim() || null : groupSelect.value || null;

            if (editingTaskId) {
                const task = tasks.find(t => t.id === editingTaskId);
                if (task) {
                    task.text = text;
                    task.group = group;
                    if (isRepetitive) {
                        const selectedDays = Array.from(document.querySelectorAll('.day-btn.selected')).map(btn => btn.dataset.day);
                        if (selectedDays.length === 0) {
                            alert('For a repetitive task, at least one day must be selected.');
                            return;
                        }
                        task.recurrence = selectedDays;
                        task.isOneTime = false;
                        task.date = null;
                        if (!task.habitTracker) {
                            task.habitTracker = { goal: 21, completedDates: [] };
                        }
                    } else { // Is one-time
                        task.recurrence = [];
                        task.isOneTime = true;
                        if (!task.date) {
                            task.date = formatDateString(currentDisplayDate);
                        }
                        delete task.habitTracker;
                    }
                }
            } else { // New task
                if (isRepetitive) {
                    const selectedDays = Array.from(document.querySelectorAll('.day-btn.selected')).map(btn => btn.dataset.day);
                    if (selectedDays.length === 0) {
                        alert('For a repetitive task, at least one day must be selected.');
                        return;
                    }
                    tasks.push({ id: generateUUID(), text, group, recurrence: selectedDays, isOneTime: false, date: null, completedOn: {}, habitTracker: { goal: 21, completedDates: [] }, creationDate: formatDateString(currentDisplayDate) });
                } else { // New one-time task
                    tasks.push({ id: generateUUID(), text, group, recurrence: [], isOneTime: true, date: formatDateString(currentDisplayDate), completedOn: {}, creationDate: formatDateString(currentDisplayDate) });
                }
            }
            syncTasksToServer();
            closeTaskModal();
            updateView();
        }
        function deleteTask() { if (editingTaskId) { tasks = tasks.filter(t => t.id !== editingTaskId); syncTasksToServer(); closeTaskModal(); updateView(); } }
        function _deleteGroup(groupName) { console.log('Deleting group:', groupName); tasks.forEach(task => { if (task.group === groupName) { task.group = null; console.log('Moved task to ungrouped:', task.id); } }); syncTasksToServer(); updateView(); }
        function openCategoryModal(groupName) { editingGroup = groupName; categoryInput.value = groupName; categoryModal.style.display = 'flex'; categoryInput.focus(); }
        function closeCategoryModal() { categoryModal.style.display = 'none'; editingGroup = null; categoryInput.value = ''; }
        function saveCategory() { if (!editingGroup || !categoryInput.value.trim()) return; const newName = categoryInput.value.trim(); if (newName === editingGroup) { closeCategoryModal(); return; } tasks.forEach(task => { if (task.group === editingGroup) task.group = newName; }); syncTasksToServer(); closeCategoryModal(); updateView(); }
        function openDeleteGroupModal(groupName) { console.log('Opening delete confirmation for group:', groupName); if (deleteGroupModal) { groupToDelete = groupName; deleteGroupModalText.textContent = `Delete the "${groupName}" group? All tasks inside will be moved to Ungrouped.`; deleteGroupModal.style.display = 'flex'; console.log('Confirmation modal set to flex'); } else { console.log('deleteGroupModal is null, cannot open'); } }
        function closeDeleteGroupModal() { deleteGroupModal.style.display = 'none'; groupToDelete = null; }
        function exportData() { const dataStr = JSON.stringify(tasks, null, 2); const dataBlob = new Blob([dataStr], { type: 'application/json' }); const url = URL.createObjectURL(dataBlob); const link = document.createElement('a'); link.download = `tasks-backup-${new Date().toISOString().slice(0, 10)}.json`; link.href = url; link.click(); URL.revokeObjectURL(url); }
        function importData(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = e => { try { const importedData = JSON.parse(e.target.result); if (!Array.isArray(importedData)) throw new Error('Invalid data format.'); if (confirm('This will overwrite all current tasks. Are you sure?')) { tasks = importedData.map(t => ({ ...t, id: t.id || generateUUID() })); syncTasksToServer(); alert('Data imported successfully!'); showTasksView(); } } catch (error) { alert(`Error importing data: ${error.message}`); } finally { importFileInput.value = ''; } }; reader.readAsText(file); }
        headerTitle.addEventListener('click', () => (tasksContainer.style.display !== 'none' ? showAnalyticsView() : showTasksView()));
        addTaskBtn.addEventListener('click', () => {
            editingTaskId = null;
            taskInput.value = '';
            deleteBtn.style.display = 'none';
            oneTimeBtn.classList.add('selected');
            repetitiveBtn.classList.remove('selected');
            daysSelection.style.display = 'none';
            document.querySelectorAll('.day-btn').forEach(btn => btn.classList.remove('selected'));
            openTaskModal();
        });
        prevDayBtn.addEventListener('click', () => { currentDisplayDate.setDate(currentDisplayDate.getDate() - 1); updateView(); });
        nextDayBtn.addEventListener('click', () => { currentDisplayDate.setDate(currentDisplayDate.getDate() + 1); updateView(); });
        currentDateElement.addEventListener('click', () => { currentDisplayDate = new Date(); updateView(); });
        cancelBtn.addEventListener('click', closeTaskModal);
        saveBtn.addEventListener('click', saveTask);
        deleteBtn.addEventListener('click', deleteTask);
        taskList.addEventListener('click', e => { if (e.target.classList.contains('group-header') && e.target.classList.contains('deletable')) openCategoryModal(e.target.dataset.group); if (e.target.classList.contains('habit-tracker')) { e.stopPropagation(); openHabitGoalModal(e.target.dataset.taskId); } });
        saveHabitGoalBtn.addEventListener('click', saveHabitGoal);
        cancelHabitGoalBtn.addEventListener('click', closeHabitGoalModal);
        cancelCategoryBtn.addEventListener('click', closeCategoryModal);
        saveCategoryBtn.addEventListener('click', saveCategory);
        deleteCategoryBtn.addEventListener('click', () => { console.log('Delete category button clicked, editingGroup:', editingGroup); if (editingGroup) { console.log('Deleting group directly:', editingGroup); _deleteGroup(editingGroup); } closeCategoryModal(); console.log('Closed category modal'); });
        cancelDeleteGroupBtn.addEventListener('click', closeDeleteGroupModal);
        confirmDeleteGroupBtn.addEventListener('click', () => { console.log('Confirm delete clicked for group:', groupToDelete); if (groupToDelete) { _deleteGroup(groupToDelete); console.log('Deletion executed'); } closeDeleteGroupModal(); });
        groupSelect.addEventListener('change', () => { newGroupInput.style.display = groupSelect.value === '--add-new--' ? 'block' : 'none'; if (groupSelect.value === '--add-new--') newGroupInput.focus(); });
        daysSelection.addEventListener('click', e => { if (e.target.classList.contains('day-btn')) { if (e.target.dataset.day === 'Daily') { const isSelected = e.target.classList.contains('selected'); document.querySelectorAll('.day-btn').forEach(btn => btn.classList.remove('selected')); if (!isSelected) e.target.classList.add('selected'); } else { document.querySelector('.day-btn[data-day="Daily"]').classList.remove('selected'); e.target.classList.toggle('selected'); } } });
        oneTimeBtn.addEventListener('click', () => {
            oneTimeBtn.classList.add('selected');
            repetitiveBtn.classList.remove('selected');
            daysSelection.style.display = 'none';
        });
        repetitiveBtn.addEventListener('click', () => {
            repetitiveBtn.classList.add('selected');
            oneTimeBtn.classList.remove('selected');
            daysSelection.style.display = 'grid';
        });
        exportBtn.addEventListener('click', exportData);
        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', importData);
        logoutBtn.addEventListener('click', handleLogout);
        taskModal.addEventListener('click', e => { if (e.target === taskModal) closeTaskModal(); });
        deleteGroupModal.addEventListener('click', e => { if (e.target === deleteGroupModal) closeDeleteGroupModal(); });
        categoryModal.addEventListener('click', e => { if (e.target === categoryModal) closeCategoryModal(); });
        habitGoalModal.addEventListener('click', e => { if (e.target === habitGoalModal) closeHabitGoalModal(); });

        document.getElementById('completionTrendSelector').addEventListener('click', e => {
            if (e.target.classList.contains('time-btn')) {
                document.querySelectorAll('#completionTrendSelector .time-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                completionTrendRange = e.target.dataset.range;
                renderAnalytics();
            }
        });

        welcomeMessage.textContent = `Logged in as {{ username }}.`;

        const logo = document.getElementById('logo');
        const menu = document.getElementById('menu');
        const headerTitle = document.getElementById('headerTitle');

        logo.addEventListener('click', (event) => {
            event.stopPropagation();
            menu.classList.toggle('show');
        });

        document.addEventListener('click', (event) => {
            if (!menu.contains(event.target) && !logo.contains(event.target)) {
                menu.classList.remove('show');
            }
        });

        showTasksView();
    </script>
</body>

</html>